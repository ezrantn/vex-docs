[{"id":0,"href":"/docs/motivation/","title":"Motivation","section":"Docs","content":" Motivation # The journey to create Vex began with a combination of academic curiosity and practical inspiration. As a student deeply interested in programming language design, I found myself drawn to the elegant simplicity of traditional UNIX text processing tools like awk and sed. These tools have stood the test of time, serving as the backbone of text manipulation in UNIX environments for decades. However, their syntax and learning curve can be challenging for newcomers, especially those from non-UNIX backgrounds.\nThis observation led me to an exciting academic opportunity - the chance to explore Domain-Specific Language (DSL) design for my thesis project. DSLs fascinate me because they represent the perfect intersection of theoretical computer science and practical utility. They\u0026rsquo;re languages crafted for specific purposes, offering the potential to create more intuitive and efficient solutions for specialized tasks.\nThe decision to focus on text processing wasn\u0026rsquo;t arbitrary. While working with various data processing tasks, I noticed a gap between the power of traditional tools and the needs of modern developers. This gap presented an opportunity to contribute something meaningful to both the academic community and practical software development.\nAcademic Goals # I\u0026rsquo;m thrilled to be developing Vex as my thesis project - pending my professor\u0026rsquo;s approval! This academic context adds an extra layer of depth to the project, as it requires not just practical implementation but also rigorous research and theoretical foundation. Through Vex, I aim to explore several key research questions:\nHow can modern programming language design principles be applied to create more intuitive text processing tools?\nWhat are the theoretical and practical considerations in designing a DSL for text processing?\nHow can we balance power and simplicity in domain-specific language design?\nDesign Philosophy # The creation of Vex represents my first venture into DSL design, making it both a learning journey and a research endeavor. My approach focuses on:\nLearning Through Creation: Building a DSL from scratch provides invaluable insights into language design principles Academic Exploration: Investigating the theoretical foundations of DSL design while creating a practical tool User-Centric Design: Focusing on making text processing more accessible without sacrificing functionality Why Text Processing? # While awk and sed are powerful tools that I deeply respect, I believe there\u0026rsquo;s room for innovation in how we approach text processing. My motivation isn\u0026rsquo;t to replace these tools, but rather to:\nCreate a more approachable entry point for newcomers to text processing Explore modern language design principles in a practical context Bridge the gap between traditional UNIX tools and contemporary programming paradigms Provide a cross-platform solution that maintains consistency across different operating systems Personal Growth # This project represents more than just a technical challenge - it\u0026rsquo;s a stepping stone in my academic journey. Through Vex, I hope to:\nGain hands-on experience in language design and implementation Contribute meaningful research to the field of domain-specific languages Create something that could potentially help others in their text processing tasks Develop a deeper understanding of both theoretical and practical aspects of programming language development As I await my professor\u0026rsquo;s approval for this thesis project, I\u0026rsquo;m excited about the potential impact Vex could have in both academic and practical contexts. The journey of creating a DSL has already taught me valuable lessons about language design, user experience, and the delicate balance between innovation and practicality.\nLooking Forward # Whether or not Vex becomes widely adopted, the process of its creation and the academic research behind it represent valuable contributions to our understanding of DSL design and implementation. I look forward to sharing my findings with the academic community and continuing to explore the fascinating world of domain-specific languages.\n"},{"id":1,"href":"/docs/system-design/","title":"System Design","section":"Docs","content":" System Design # Vex employs a deliberately streamlined architecture that prioritizes simplicity and performance. Unlike many traditional language implementations that utilize Abstract Syntax Trees (AST), Vex takes a more direct approach with just two main components:\nLexer: Handles token generation Parser: Processes tokens and executes commands directly This design decision was made to minimize processing overhead while maintaining functionality for text processing operations.\nDesign Rationale # Why No AST? # The decision to omit an AST was deliberate, based on several key factors:\nSimplified Syntax: Vex\u0026rsquo;s domain-specific nature means its syntax is straightforward enough that an AST would add unnecessary complexity Performance Focus: Direct token processing reduces memory allocation and garbage collection overhead Streaming Capability: The simplified architecture allows for efficient streaming of large text files Reduced Complexity: Fewer components mean fewer potential points of failure Processing Pipeline # The text processing pipeline follows a simple flow:\nInput Text → Lexer → Token Stream → Parser → Output This streamlined approach enables:\nMinimal memory footprint Direct processing of tokens Efficient handling of large files Performance Considerations # The simplified architecture brings several performance benefits:\nMemory Efficiency\nNo tree structure allocation/deallocation Reduced garbage collection pressure Lower memory footprint Processing Speed\nDirect token processing without tree traversal Streamlined execution path Fewer object allocations Scalability\nEfficient handling of large files Linear processing complexity Predictable resource usage Error Handling # Error handling is implemented at both lexer and parser levels:\nLexer: Handles character-level and token-level errors Parser: Manages syntax and semantic errors Runtime: Handles execution and I/O errors Future Considerations # While the current design is intentionally minimal, the architecture allows for future enhancements:\nParallel processing capabilities Extended command set Plugin system Performance optimizations The design\u0026rsquo;s simplicity makes it easier to maintain and extend while keeping the core functionality efficient and reliable.\nDevelopment Workflow # The development process follows these principles:\nMaintain simplicity in both design and implementation Prioritize performance in architectural decisions Ensure robust error handling Keep the codebase maintainable and well-documented This architectural approach demonstrates that sometimes less is more - by focusing on essential components and eliminating unnecessary complexity, Vex achieves its goals of simplicity, performance, and reliability in text processing tasks.\n"},{"id":2,"href":"/docs/usage/","title":"Usage","section":"Docs","content":" Usage # The heart of Vex lies in its straightforward syntax:\nvex [command] [pattern] Examples # vex replace \u0026#34;foo:bar=input.txt\u0026#34; vex load \u0026#34;:=input.txt\u0026#34; vex save \u0026#34;:=output\u0026#34; vex filter \u0026#34;Hello=world.js\u0026#34; "},{"id":3,"href":"/docs/getting-started/","title":"Getting Started","section":"Docs","content":" Getting Started # For now, feel free to experiment with Vex’s initial capabilities. You can find a basic usage guide below:\nPrerequisites # Ensure the following is installed:\nGo (v1.23 or higher) Installation # You can install Vex by running a following command:\ngo install github.com/ezrantn/vex@latest Check if Vex already installed in your system:\nvex version "},{"id":4,"href":"/docs/status/","title":"Status","section":"Docs","content":" Status # Vex is currently in active development. While initial capabilities are available for exploration, further enhancements and detailed documentation are in progress. Updates and new features will be shared as they become available.\n"},{"id":5,"href":"/docs/features/filtering/","title":"Filtering","section":"Features","content":" Filtering # To filter a word in your file, you can run the following command:\nvex filter \u0026#34;Hello=world.js\u0026#34; This command is equivalent to the format:\n[word=\u0026lt;textinput\u0026gt;] Example Output:\nPattern: \u0026#34;Hello\u0026#34; File: world.js Total Matches: 3 Match 1: Line 5: console.log(\u0026#34;Hello\u0026#34;) Match 2: Line 6: console.log(\u0026#34;Hello\u0026#34;) Match 3: Line 7: console.log(\u0026#34;Hello\u0026#34;) "},{"id":6,"href":"/docs/features/find-and-replace/","title":"Find and Replace","section":"Features","content":" Find and Replace # To perform a find-and-replace operation on a file using Vex, follow this syntax:\nvex replace \u0026#34;foo:bar=input.txt\u0026#34; Explanation:\nfoo: The text you want to find. bar: The text you want to replace it with. input.txt: The file where the operation will be performed. This command follows the general format:\n[find:replace=\u0026lt;textinput\u0026gt;] Case Sensitivity # By default, the replace command is case sensitive. To make it case insensitive, add the -i flag:\nvex replace \u0026#34;foo:bar=input.txt\u0026#34; -i -i: Enables case-insensitive matching for the find-and-replace operation. "},{"id":7,"href":"/docs/features/input-output/","title":"Input Output","section":"Features","content":" Input / Output # To load a text file into memory, you can use the following command:\nvex load \u0026#34;:=input.txt\u0026#34; To save the current content to a file, use:\nvex save \u0026#34;:=output\u0026#34; "}]